import {
    $query,
    $update,
    Record,
    StableBTreeMap,
    Vec,
    match,
    Result,
    nat64,
    ic,
    Opt,
    Principal,
} from 'azle';
import { v4 as uuidv4 } from 'uuid';

type Employee = Record<{
    id: string;
    employer_principal: Principal;
    firstName: string;
    lastName: string;
    position: string;
    department: string;
    salary: number;
    isEmployed: boolean;
    updatedAt: Opt<nat64>;
}>;

type EmployeePayload = Record<{
    firstName: string;
    lastName: string;
    position: string;
    department: string;
    salary: number;
}>;
const employeeStorage = new StableBTreeMap<string, Employee>(0, 44, 1024);

// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
    return str.trim().length == 0
}

// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
    const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
    return regexExp.test(id);
}

function isFired(employee: Employee): boolean {
    return employee.isEmployed == false;
}

$query
export function searchEmployees(query: string): Result<Vec<Employee>, string> {
    try {
        const lowerCaseQuery = query.toLowerCase();
        const includesQuery = (str:string) => str.toLowerCase().includes(lowerCaseQuery);
        const filteredEmployees = employeeStorage.values().filter(
            (employee) =>
                includesQuery(employee.firstName) ||
                includesQuery(employee.lastName) ||
                includesQuery(employee.position) ||
                includesQuery(employee.department)
        );
        return Result.Ok(filteredEmployees);
    } catch (error) {
        return Result.Err(`Error searching for an employee: ${error}`);
    }
}

$update
export function hireEmployee(payload: EmployeePayload): Result<Employee, string> {
    try {
        // Validate the employee object
        if (isInvalidString(payload.firstName) || isInvalidString(payload.lastName) || isInvalidString(payload.position) || isInvalidString(payload.department) || payload.salary == 0) {
            return Result.Err('Missing required fields in the employee object');
        }
        let employee: Employee = {
            id: uuidv4(),
            employer_principal: ic.caller(),
            isEmployed: true,
            updatedAt : Opt.Some(ic.time()),
            ...payload,   
        }

        // Add the employee to employeeStorage
        employeeStorage.insert(employee.id, employee);

        return Result.Ok(employee);
    } catch (error) {
        return Result.Err(`Error hiring employee: ${error}`);
    }
}

$update
export function fireEmployee(id: string): Result<Employee, string> {
    // Validate the id parameter
    if (!isValidUuid(id)) {
        return Result.Err('Invalid employee ID');
    }
    return match(employeeStorage.get(id), {
        Some: (employee) => {
            if (!employee.isEmployed) {
                return Result.Err<Employee, string>(`Employee with id=${id} is already terminated`);
            }

            const terminatedEmployee: Employee = { ...employee, isEmployed: false };
            employeeStorage.insert(id, terminatedEmployee);

            return Result.Ok(terminatedEmployee);
        },
        None: () => Result.Err<Employee, string>(`Employee with id=${id} not found`),
    }) as Result<Employee, string>;
}

$update
export function updateEmployee(id: string, payload: EmployeePayload): Result<Employee, string> {
    // Validate the id parameter
    if (!isValidUuid(id)) {
        return Result.Err('Invalid employee ID');
    }
    return match(employeeStorage.get(id), {
        Some: (existingEmployee) => {
        // Validate the employee object
        if (isInvalidString(payload.firstName) || isInvalidString(payload.lastName) || isInvalidString(payload.position) || isInvalidString(payload.department) || payload.salary == 0) {
            return Result.Err('Missing required fields in the employee object');
        }

        if (ic.caller().toString() !== existingEmployee.employer_principal.toString()){
            return Result.Err("Caller isn't the employer");
        }

            // Create a new employee object with the updated fields
            const updatedEmployee: Employee = {
                ...existingEmployee,
                ...payload,
                updatedAt: Opt.Some(ic.time()),
            };

            // Update the employee in employeeStorage
            employeeStorage.insert(id, updatedEmployee);

            return Result.Ok(updatedEmployee);
        },
        None: () => Result.Err<Employee, string>(`Employee with id=${id} does not exist`),
    }) as Result<Employee, string>;
}

$query
export function getEmployees(): Result<Vec<Employee>, string> {
    try {
        const employees = employeeStorage.values();
        return Result.Ok(employees);
    } catch (error) {
        return Result.Err(`Error getting employees: ${error}`);
    }
}

$query
export function getEmployee(id: string): Result<Employee, string> {
    // Validate the id parameter
    if (!isValidUuid(id)) {
        return Result.Err('Invalid employee ID');
    }
    return match(employeeStorage.get(id), {
        Some: (employee) => Result.Ok<Employee, string>(employee),
        None: () => Result.Err<Employee, string>(`Employee with id=${id} not found`),
    }) as Result<Employee, string>;
}

$update
export function deleteEmployee(id: string): Result<Opt<Employee>, string> {
    try {
        // Validate the id parameter
        if (!isValidUuid(id)) {
            return Result.Err('Invalid employee ID');
        }

        // Delete the employee from employeeStorage
        const employee = employeeStorage.get(id);
        if (!employee.Some){
            return Result.Err("Employee with ID ${id} does not exist")
        }
        if (ic.caller().toString() !== employee.Some.employer_principal.toString()){
            return Result.Err("Caller isn't the employer");
        }

        employeeStorage.remove(id);

        return Result.Ok(employee);
    } catch (error) {
        return Result.Err(`Error deleting employee: ${error}`);
    }
}

$update
export function promoteEmployee(id: string): Result<Employee, string> {
    // Validate the id parameter
    if (!isValidUuid(id)) {
        return Result.Err('Invalid employee ID');
    }
    return match(employeeStorage.get(id), {
        Some: (employee) => {
            if (ic.caller().toString() !== employee.employer_principal.toString()){
                return Result.Err("Caller isn't the employer");
            }
            if (isFired(employee)){
                return Result.Err("Employee was fired");
            }
            // Assuming a simple promotion by adding "Senior " to the position
            const promotedEmployee: Employee = { ...employee, position: `Senior ${employee.position}` };
            employeeStorage.insert(id, promotedEmployee);

            return Result.Ok(promotedEmployee);
        },
        None: () => Result.Err<Employee, string>(`Employee with id=${id} not found`),
    }) as Result<Employee, string>;
}

$update
export function demoteEmployee(id: string): Result<Employee, string> {
    // Validate the id parameter
    if (!isValidUuid(id)) {
        return Result.Err('Invalid employee ID');
    }
    return match(employeeStorage.get(id), {
        Some: (employee) => {
            if (ic.caller().toString() !== employee.employer_principal.toString()){
                return Result.Err("Caller isn't the employer");
            }
            if (isFired(employee)){
                return Result.Err("Employee was fired");
            }
            // Assuming a simple demotion by removing "Senior " from the position
            const demotedEmployee: Employee = { ...employee, position: employee.position.replace(/^Senior /, '') };
            employeeStorage.insert(id, demotedEmployee);

            return Result.Ok(demotedEmployee);
        },
        None: () => Result.Err<Employee, string>(`Employee with id=${id} not found`),
    }) as Result<Employee, string>;
}

$update
export function increaseSalary(id: string, amount: number): Result<Employee, string> {
    // Validate the id parameter
    if (!isValidUuid(id)) {
        return Result.Err('Invalid employee ID');
    }
    return match(employeeStorage.get(id), {
        Some: (employee) => {
            if (ic.caller().toString() !== employee.employer_principal.toString()){
                return Result.Err("Caller isn't the employer");
            }
            if (isFired(employee)){
                return Result.Err("Employee was fired");
            }
            // Increase the salary by the specified amount
            const increasedSalaryEmployee: Employee = { ...employee, salary: employee.salary + amount };
            employeeStorage.insert(id, increasedSalaryEmployee);

            return Result.Ok(increasedSalaryEmployee);
        },
        None: () => Result.Err<Employee, string>(`Employee with id=${id} not found`),
    }) as Result<Employee, string>;
}
// A workaround to make the uuid package work with Azle
globalThis.crypto = {
    // @ts-ignore
    getRandomValues: () => {
        let array = new Uint8Array(32);

        for (let i = 0; i < array.length; i++) {
            array[i] = Math.floor(Math.random() * 256);
        }

        return array;
    },
};
